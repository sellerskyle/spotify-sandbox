# -*- coding: utf-8 -*-
"""SpotifyUserPlayground.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aqascWwki2p6tKXutqsUuGri6XEWD_A_

This notebook serves as a playground for experimenting with data science using Python and Spotify APIs. This one focuses on the a user logging in and extracting a user's data

First we install a few necessary libraries
"""

!pip install -q numpy
!pip install -q pandas
!pip install requests

"""Next, we are using a spotify API client made using a tutorial found here: [video](https://www.youtube.com/watch?v=xdq6Gz33khQ) [GitHub](https://github.com/codingforentrepreneurs/30-Days-of-Python/blob/master/tutorial-reference/Day%2019/notebooks/spotify_client.py)

This class has been altered to add more access functions, and in this notebook, added the ability for a user to login.
"""

import base64
import datetime
from urllib.parse import urlencode

import requests

#Follows Spotify's "Implicit Grant" Authorization flow
class SpotifyAPI(object):
    access_token = None
    access_token_expires = datetime.datetime.now()
    access_token_did_expire = True
    client_id = None
    client_secret = None
    token_url = "https://accounts.spotify.com/api/token"
    authorization_url = "https://accounts.spotify.com/authorize"
    
    #external functions ("public")
    

    def __init__(self, client_id, client_secret, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client_id = client_id
        self.client_secret = client_secret

    def get_album(self, _id):
        return self.get_resource(_id, resource_type='albums')
    
    def get_artist(self, _id):
        return self.get_resource(_id, resource_type='artists')

    def get_playlist(self, _id):
        return self.get_resource(_id, resource_type='playlists')

    def get_playlist_tracks(self, _id):
        return self.get_resource(_id, resource_type='playlists', addendum='tracks')

    def get_track_features(self, _id):
        return self.get_resource(_id, resource_type='audio-features')

    def get_track_analysis(self, _id):
      return self.get_resource(_id, resource_type='audio-analysis') 

    def search(self, query=None, operator=None, operator_query=None, search_type='artist', limit=20 ):
        if query == None:
            raise Exception("A query is required")
        if isinstance(query, dict):
            query = " ".join([f"{k}:{v}" for k,v in query.items()])
        if operator != None and operator_query != None:
            if operator.lower() == "or" or operator.lower() == "not":
                operator = operator.upper()
                if isinstance(operator_query, str):
                    query = f"{query} {operator} {operator_query}"
        query_params = urlencode({"q": query, "type": search_type.lower(), "limit": str(limit)})
        return self.base_search(query_params)


    #internal functions ("private")


    def get_client_credentials(self):
        """
        Returns a base64 encoded string
        """
        client_id = self.client_id
        client_secret = self.client_secret
        if client_secret == None or client_id == None:
            raise Exception("You must set client_id and client_secret")
        client_creds = f"{client_id}:{client_secret}"
        client_creds_b64 = base64.b64encode(client_creds.encode())
        return client_creds_b64.decode()
    
    def get_token_headers(self):
        client_creds_b64 = self.get_client_credentials()
        return {
            "Authorization": f"Basic {client_creds_b64}"
        }
    
    def get_token_data(self):
        return {
            "grant_type": "client_credentials"
        } 
    
    def perform_auth(self):
        token_url = self.token_url
        token_data = self.get_token_data()
        token_headers = self.get_token_headers()
        r = requests.post(token_url, data=token_data, headers=token_headers)
        if r.status_code not in range(200, 299):
            raise Exception("Could not authenticate client.")
            # return False
        data = r.json()
        now = datetime.datetime.now()
        access_token = data['access_token']
        expires_in = data['expires_in'] # seconds
        expires = now + datetime.timedelta(seconds=expires_in)
        self.access_token = access_token
        self.access_token_expires = expires
        self.access_token_did_expire = expires < now
        return True
    
    def get_access_token(self):
        token = self.access_token
        expires = self.access_token_expires
        now = datetime.datetime.now()
        if expires < now:
            self.perform_auth()
            return self.get_access_token()
        elif token == None:
            self.perform_auth()
            return self.get_access_token() 
        return token
    
    def get_resource_header(self):
        access_token = self.get_access_token()
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        return headers
        
        
    def get_resource(self, lookup_id, resource_type='albums', version='v1', addendum=''):
        endpoint = f"https://api.spotify.com/{version}/{resource_type}/{lookup_id}/{addendum}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()
    
    
    
    def base_search(self, query_params): # type
        headers = self.get_resource_header()
        endpoint = "https://api.spotify.com/v1/search"
        lookup_url = f"{endpoint}?{query_params}"
        r = requests.get(lookup_url, headers=headers)
        if r.status_code not in range(200, 299):  
            return {}
        return r.json()

    #new functions for user functions

    def get_current_user(self):
        endpoint = f"https://api.spotify.com/v1/me"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_current_user_recently_played(self):
        endpoint = f"https://api.spotify.com/v1/me/player/recently-played"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_current_user_top(self, top_type='tracks', time_range='medium_term'):
        #endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?limit=50&time_range{time_range}"
        endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?time_range={time_range}&limit=50"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            return {}
        return r.json()

    def get_current_user_top_amount(self, top_type='tracks', time_range='medium_term', amount=50):
        headers = self.get_resource_header()
        received_resources = 0
        return_list = []
        limit = amount % 50
        while received_resources < amount:
          endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?time_range={time_range}&limit={str(limit)}&offset={received_resources}"
          r = requests.get(endpoint, headers=headers)
          if r.status_code not in range(200, 299):
              return {}
          return_list.append(r.json()['items'])

    def get_user(self, user):
        endpoint = f"https://api.spotify.com/v1/users/{user}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

"""Let's not forget to import the all powerful datascience libraries: NumPy and pandas !"""

import webbrowser
import json

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
import math

"""Now, we pass our client ID and client secret from our Spotify Dev project into an instance of the spotify_client class. Paste in your own within the quotes. To get a your Spotify credentials, visit [here](https://developer.spotify.com/dashboard/login)"""

client_id = ""
client_secret = ""

"""Add the appropriate scopes for getting the correct access token for a user."""

scopes = ['user-read-email', 'user-read-private', 'playlist-read-collaborative', 'playlist-modify-public', 'playlist-read-private', 'playlist-modify-private', 'user-library-read', 'user-top-read', 'user-read-recently-played', 'user-modify-playback-state', 'user-read-playback-state']
scopes_string = ' '.join(scopes)
scopes_string

"""Creating the GET request to log a user in. Follow the link generated to allow access to user data"""

authorization_url = "https://accounts.spotify.com/authorize"


params = {
            "client_id": client_id,
            "response_type": "token",
            "redirect_uri": "http://localhost:7777/callback",
            "scope": scopes_string
        } 
r = requests.get(authorization_url, params)
print("Successful if this is 200: " + str(r.status_code))
print("URL to paste in browser: " + str(r.url))

"""Now paste the entire url you were sent to after allowing permissions between the quotes for "response =""""

#paste the entire url you are sent to here as a string(in quotes
response = ''
response_list_raw = response.split('&')

response_list = []
#hard coded extracting token and expires
for item in response_list_raw:
  response_list.append(item.split('='))

response_list

access_token = response_list[0][1]
expires_in = response_list[2][1]
print(access_token)
print(expires_in)

"""Now I have a token! Let's try it out by trying to access generic data"""

spotify_nouser = SpotifyAPI(client_id, client_secret)
spotify_user = SpotifyAPI(client_id, client_secret)

spotify_user.access_token = access_token
spotify_user.access_token_expires = datetime.datetime.now() + datetime.timedelta(seconds=3600)
spotify_user.access_token_did_expire = False

nu = spotify_nouser.search("Khalid", search_type='artist')

u = spotify_user.search("Khalid", search_type='artist')

print(spotify_nouser.access_token)
print(nu)
print(spotify_user.access_token)
print(u)

"""It works! Now let's try to access some user data."""

current_user_raw = spotify_user.get_current_user()
current_user_raw

recently_played = spotify_user.get_current_user_recently_played()
recently_played

"""Great, that worked! Let's see what your top songs are!"""

top_tracks_raw = spotify_user.get_current_user_top(top_type='tracks', time_range='long_term')
top_tracks = top_tracks_raw['items']
len(top_tracks)

top_artists_raw = spotify_user.get_current_user_top(top_type='artists', time_range='short_term')
top_artists = top_artists_raw['items']
len(top_artists)

indices = {'resource_types':['tracks','artists'],'time_frames':['short_term','medium_term', 'long_term']}

raw_file_data = {}
for resource_type in indices['resource_types']:
  for time_frame in indices['time_frames']:
    index_string = resource_type + "_" + time_frame
    raw_file_data[index_string] = spotify_user.get_current_user_top(top_type=resource_type, time_range=time_frame)['items']

raw_file_data['profile'] = spotify_user.get_current_user()

file_name = raw_file_data['profile']['id'] + '.json'
with open(file_name, 'w') as outfile:
    json.dump(raw_file_data, outfile)

"""Let's put this data in a json file in a json file and download it!"""

!ls

# Download the file.
from google.colab import files
files.download(file_name)

"""Begin user Data Processing"""

with open(file_name) as json_file:
    user_data = json.load(json_file)

#adding ranking to each item in user data

for resource_type in indices['resource_types']:
  for time_frame in indices['time_frames']:
    rank = 0
    for resource in user_data[resource_type + '_' + time_frame]:
      rank += 1
      resource['rank'] = rank

user_data

all_tracks_raw = []

all_tracks_raw = all_tracks_raw + user_data['tracks_short_term']
all_tracks_raw = all_tracks_raw + user_data['tracks_medium_term']
all_tracks_raw = all_tracks_raw + user_data['tracks_long_term']


all_artists_raw = []

all_artists_raw = all_artists_raw + user_data['artists_short_term']
all_artists_raw = all_artists_raw + user_data['artists_medium_term']
all_artists_raw = all_artists_raw + user_data['artists_long_term']

print(len(all_tracks_raw))

set_of_track_jsons = {json.dumps(d, sort_keys=True) for d in all_tracks_raw}
all_tracks_no_dup = [json.loads(t) for t in set_of_track_jsons]

print(len(all_tracks_no_dup))

print(len(all_artists_raw))

set_of_artist_jsons = {json.dumps(d, sort_keys=True) for d in all_artists_raw}
all_artists_no_dup = [json.loads(t) for t in set_of_artist_jsons]

print(len(all_artists_no_dup))

"""Artist visualization for user top tracks"""

#Finding avg popularity of artists you listen to
total_artist_pop = 0
for artist in all_artists_no_dup:
  total_artist_pop = total_artist_pop + artist['popularity']

avg_artist_pop = total_artist_pop / len(all_artists_no_dup)
avg_artist_pop

"""Here's a bar graph of your top genres! (Hint: right click the image and open in new tab to zoom in)"""

#Most prominent genre's of artists you listen to

genre_dict = {}


for artist in all_artists_no_dup:
  for genre in artist['genres']:
    if genre in genre_dict:
      genre_dict[genre] = genre_dict[genre] + 1
    else:
      genre_dict[genre] = 1

genre_dict
sort_genre_dict = sorted(genre_dict.items(), key=lambda x: x[1], reverse=True)
print("dimensions: " + str(len(sort_genre_dict)) + " x " + str(len(sort_genre_dict[0])))
df = pd.DataFrame(sort_genre_dict, columns=['genre', 'count'])
sns.set(style="darkgrid")


fig_dims = (900, 20)
fig, ax = plt.subplots(figsize=fig_dims)
sns.barplot(x='genre', y='count', data=df, ax=ax)

#finding percent of your top songs that are by your top artists

top_artists_names = []

for artist in all_artists_no_dup:
  top_artists_names.append(artist['name'])

all_tracks_no_dup[0]

top_tracks_names_plus_artists = []
for track in all_tracks_no_dup:
  name = track['name']
  artist_names = []
  for artist in track['artists']:
    artist_names.append(artist['name'])
  top_tracks_names_plus_artists.append({'name': name, 'artists': artist_names})

top_tracks_names_plus_artists

num_tracks_by_fav_artists = 0

tracks_not_by_fav_artists = []



for track in top_tracks_names_plus_artists:
  this_track_by_fav_artist = False
  for artist in track['artists']:
    for top_artist in top_artists_names:
      if artist == top_artist:
        num_tracks_by_fav_artists = num_tracks_by_fav_artists + 1
        this_track_by_fav_artist = True
  if not this_track_by_fav_artist:
    tracks_not_by_fav_artists.append(track)

print(num_tracks_by_fav_artists)
print(tracks_not_by_fav_artists)
print(top_artists_names)

#find all top artists that match a provided genre
target_genre = 'pop rap'

artists_belonging_to_genre = []

for artist in all_artists_no_dup:
  for genre in artist['genres']:
    if target_genre == genre:
      artists_belonging_to_genre.append(artist['name'])

artists_belonging_to_genre

"""The previous graph was a sum of all artists that fit in a genre, over your entire listening history on spotify. Let's weight these artists so the ones you listened to recently are more important"""

#weighted graph of favorite genres

#lets start small with just short term songs weighting

short_term_weight = 0.8
medium_term_weight = 0.1
long_term_weight = 0.1

short_term_scaling = 10
medium_term_scaling = 5
long_term_scaling = 3

time_frame_weights_scalings = {
    'short_term': {'weight': short_term_weight,'scaling':short_term_scaling},
    'medium_term': {'weight': medium_term_weight,'scaling':medium_term_scaling},
    'long_term': {'weight': long_term_weight,'scaling':long_term_scaling}
}

# test_list = np.arange(1,51,1)
# test_list

# scaling = 10
# amount_per_step = ((scaling-1)/scaling) / (len(test_list) - 1)
# amount_per_step

# scaled_list = []

# for item in test_list:
#   val = 1/scaling + ((len(test_list) - (item)) * amount_per_step)
#   scaled_list.append(val)

# scaled_list
genre_dict_scaled = {}

for time_frame in indices['time_frames']:
  scaling = time_frame_weights_scalings[time_frame]['scaling']
  for artist in user_data['artists_' + time_frame]:
    amount_per_step = ((scaling-1)/scaling) / (len(user_data['artists_' + time_frame]) - 1)
    for genre in artist['genres']:
      if genre in genre_dict_scaled:
        genre_dict_scaled[genre] += (1/scaling + ((len(user_data['artists_' + time_frame]) - (artist['rank'])) * amount_per_step)) * time_frame_weights_scalings[time_frame]['weight']
      else:
        genre_dict_scaled[genre] = (1/scaling + ((len(user_data['artists_' + time_frame]) - (artist['rank'])) * amount_per_step)) * time_frame_weights_scalings[time_frame]['weight']
      # print((1/scaling + ((len(user_data['artists_' + time_frame]) - (item)) * amount_per_step)) * time_frame_weights_scalings[time_frame]['weight'])


genre_dict_scaled
sorted_genre_dict_scaled = sorted(genre_dict_scaled.items(), key=lambda x: x[1], reverse=True)
sorted_genre_dict_scaled

df_scaled = pd.DataFrame(sorted_genre_dict_scaled, columns=['genre', 'weight'])
sns.set(style="darkgrid")


fig_dims = (900, 20)
fig, ax = plt.subplots(figsize=fig_dims)
sns.barplot(x='genre', y='weight', data=df_scaled, ax=ax)

#log plot?
sorted_genre_dict_scaled_log = []


minimum = sorted_genre_dict_scaled[len(sorted_genre_dict_scaled) - 1][1]


for entry in sorted_genre_dict_scaled:
  new_entry = {}
  new_entry[entry[0]] = math.log(entry[1]/minimum)
  sorted_genre_dict_scaled_log.append(new_entry)

sorted_genre_dict_scaled_log

# df_scaled_log = pd.DataFrame(sorted_genre_dict_scaled_log, columns=['genre', 'weight'])
# sns.set(style="darkgrid")
# df_scaled_log

# fig_dims = (900, 20)
# fig, ax = plt.subplots(figsize=fig_dims)
# sns.barplot(x='genre', y='weight', data=df_scaled_log, ax=ax)

analytics = df_scaled.describe()
type(analytics)
mean = analytics['weight']['mean']
sorted_genre_dict_scaled
gt_mean = [x for x in sorted_genre_dict_scaled if x[1] > mean]
gt_mean