# -*- coding: utf-8 -*-
"""SpotifyTestLab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Di9GbZB-zYgD00H-Wjrz3D-ecP9uxJ0

This Notebook serves as a test lab for functions used in other notebooks. Therefore, it is a true mixed bag of functions haphazardly mixed in.

We are using a spotify API client made using a tutorial found here: [video](https://www.youtube.com/watch?v=xdq6Gz33khQ) [GitHub](https://github.com/codingforentrepreneurs/30-Days-of-Python/blob/master/tutorial-reference/Day%2019/notebooks/spotify_client.py)
"""

import base64
import datetime
from urllib.parse import urlencode

import requests

#Follows Spotify's "Implicit Grant" Authorization flow
class SpotifyAPI(object):
    access_token = None
    access_token_expires = datetime.datetime.now()
    access_token_did_expire = True
    client_id = None
    client_secret = None
    token_url = "https://accounts.spotify.com/api/token"
    authorization_url = "https://accounts.spotify.com/authorize"
    
    #external functions ("public")
    

    def __init__(self, client_id, client_secret, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client_id = client_id
        self.client_secret = client_secret

    def get_album(self, _id):
        return self.get_resource(_id, resource_type='albums')
    
    def get_artist(self, _id):
        return self.get_resource(_id, resource_type='artists')

    def get_playlist(self, _id):
        return self.get_resource(_id, resource_type='playlists')

    def get_playlist_tracks(self, _id):
        return self.get_resource(_id, resource_type='playlists', addendum='tracks')

    def get_track_features(self, _id):
        return self.get_resource(_id, resource_type='audio-features')

    def get_track_analysis(self, _id):
      return self.get_resource(_id, resource_type='audio-analysis') 

    def search(self, query=None, operator=None, operator_query=None, search_type='artist', limit=20 ):
        if query == None:
            raise Exception("A query is required")
        if isinstance(query, dict):
            query = " ".join([f"{k}:{v}" for k,v in query.items()])
        if operator != None and operator_query != None:
            if operator.lower() == "or" or operator.lower() == "not":
                operator = operator.upper()
                if isinstance(operator_query, str):
                    query = f"{query} {operator} {operator_query}"
        query_params = urlencode({"q": query, "type": search_type.lower(), "limit": str(limit)})
        return self.base_search(query_params)


    #internal functions ("private")


    def get_client_credentials(self):
        """
        Returns a base64 encoded string
        """
        client_id = self.client_id
        client_secret = self.client_secret
        if client_secret == None or client_id == None:
            raise Exception("You must set client_id and client_secret")
        client_creds = f"{client_id}:{client_secret}"
        client_creds_b64 = base64.b64encode(client_creds.encode())
        return client_creds_b64.decode()
    
    def get_token_headers(self):
        client_creds_b64 = self.get_client_credentials()
        return {
            "Authorization": f"Basic {client_creds_b64}"
        }
    
    def get_token_data(self):
        return {
            "grant_type": "client_credentials"
        } 
    
    def perform_auth(self):
        token_url = self.token_url
        token_data = self.get_token_data()
        token_headers = self.get_token_headers()
        r = requests.post(token_url, data=token_data, headers=token_headers)
        if r.status_code not in range(200, 299):
            raise Exception("Could not authenticate client.")
            # return False
        data = r.json()
        now = datetime.datetime.now()
        access_token = data['access_token']
        expires_in = data['expires_in'] # seconds
        expires = now + datetime.timedelta(seconds=expires_in)
        self.access_token = access_token
        self.access_token_expires = expires
        self.access_token_did_expire = expires < now
        return True
    
    def get_access_token(self):
        token = self.access_token
        expires = self.access_token_expires
        now = datetime.datetime.now()
        if expires < now:
            self.perform_auth()
            return self.get_access_token()
        elif token == None:
            self.perform_auth()
            return self.get_access_token() 
        return token
    
    def get_resource_header(self):
        access_token = self.get_access_token()
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        return headers
        
        
    def get_resource(self, lookup_id, resource_type='albums', version='v1', addendum=''):
        endpoint = f"https://api.spotify.com/{version}/{resource_type}/{lookup_id}/{addendum}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()
    
    
    
    def base_search(self, query_params): # type
        headers = self.get_resource_header()
        endpoint = "https://api.spotify.com/v1/search"
        lookup_url = f"{endpoint}?{query_params}"
        r = requests.get(lookup_url, headers=headers)
        if r.status_code not in range(200, 299):  
            return {}
        return r.json()

    #generic api request, accepts the full endpoint string

    def generic_get(self, endpoint):
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            if r.status_code == 429:
              print('Retry after ' + str(r.headers['Retry-After']) + ' seconds')
              raise Exception("You are requesting too much data, retry after " + str(r.headers['Retry-After']) + ' seconds')
            return {}
        return r.json()

    def generic_post(self, endpoint):
        headers = self.get_resource_header()
        r = requests.post(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            return {}
        return r.json()

    def generic_put(self, endpoint):
        headers = self.get_resource_header()
        r = requests.put(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)

    #new functions for user functions

    def get_current_user(self):
        endpoint = f"https://api.spotify.com/v1/me"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_current_user_recently_played(self):
        endpoint = f"https://api.spotify.com/v1/me/player/recently-played"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_current_user_top(self, top_type='tracks', time_range='medium_term'):
        #endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?limit=50&time_range{time_range}"
        endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?time_range={time_range}&limit=50"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            return {}
        return r.json()

    def get_user(self, user):
        endpoint = f"https://api.spotify.com/v1/users/{user}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

import webbrowser
import json

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt

"""Now, we pass our client ID and client secret from our Spotify Dev project into an instance of the spotify_client class. Paste in your own within the quotes. To get a your Spotify credentials, visit [here](https://developer.spotify.com/dashboard/login)"""

client_id = ""
client_secret = ""

spotify =  SpotifyAPI(client_id, client_secret)

scopes = ['user-read-email', 'user-read-private', 'playlist-read-collaborative', 'playlist-modify-public', 'playlist-read-private', 'playlist-modify-private', 'user-library-read', 'user-top-read', 'user-read-recently-played', 'user-modify-playback-state']
scopes_string = ' '.join(scopes)
authorization_url = "https://accounts.spotify.com/authorize"


params = {
            "client_id": client_id,
            "response_type": "token",
            "redirect_uri": "http://localhost:7777/callback",
            "scope": scopes_string
        }

"""Follow the link generated to allow access to user data"""

r = requests.get(authorization_url, params)
print("Successful if this is 200: " + str(r.status_code))
print("URL to paste in browser: " + str(r.url))

"""Now paste the entire url you were sent to after allowing permissions between the quotes for "response =""""

#paste the entire url you are sent to here as a string(in quotes
response = ''
response_list_raw = response.split('&')

response_list = []
#hard coded extracting token and expires
for item in response_list_raw:
  response_list.append(item.split('='))

response_list

access_token = response_list[0][1]
expires_in = response_list[2][1]
print(access_token)

spotify_user = SpotifyAPI(client_id, client_secret)

spotify_user.access_token = access_token
spotify_user.access_token_expires = datetime.datetime.now() + datetime.timedelta(seconds=3600)
spotify_user.access_token_did_expire = False

nu = spotify.search("Khalid", search_type='artist')

u = spotify_user.search("Khalid", search_type='artist')

print(spotify.access_token)
print(nu)
print(spotify_user.access_token)
print(u)

"""End Initialization and test. Begin New stuff"""

#seeing getting all possible recommendation genres for getting reccommnedations
all_recommend_genres = spotify.generic_get('https://api.spotify.com/v1/recommendations/available-genre-seeds')
all_recommend_genres

"""Getting reccommended tracks based on a track passed to api"""

recommendations = spotify.generic_get('https://api.spotify.com/v1/recommendations?seed_tracks=5qVJUvV1lyAwJnNKFMqurK')#('https://api.spotify.com/v1/recommendations?seed_genres='+genre+'&seed_tracks='+track+'&seed_artists='+artist) --currently appelsinskal


for track in recommendations['tracks']:
  print(track['name'] +' artist: '+ track['artists'][0]['name'])

"""Messing aroung with the player

# **PAUSE**
"""

spotify_user.generic_put('https://api.spotify.com/v1/me/player/pause')

"""# **PLAY**"""

spotify_user.generic_put('https://api.spotify.com/v1/me/player/play')

"""#**VOLUME SWEEP UP**"""

speed = 10

for volume in range(0, 101, speed):
  spotify_user.generic_put('https://api.spotify.com/v1/me/player/volume?volume_percent=' + str(volume))

"""#**VOLUME SWEEP DOWN**"""

for volume in range(0, 101, speed):
  spotify_user.generic_put('https://api.spotify.com/v1/me/player/volume?volume_percent=' + str(100 - volume))

"""Getting similar artists"""

artist = '0XDfNJsQy7B3q0GfsMHSkp'
similar_artists = spotify.generic_get(f'https://api.spotify.com/v1/artists/{artist}/related-artists')

len(similar_artists)
len(similar_artists['artists'])

for artist in similar_artists['artists']:
  print(artist['name'])

"""Creating 1 user artist constellation, using json files generated in SpotifyUserPlayground or GetUserData"""

from google.colab import files
uploaded = files.upload()

!ls

#choose next line to be same name as file uploaded (for example, john.smith.json)
user_file_name = ''

with open(user_file_name) as json_file:
    user_data = json.load(json_file)

print(user_data)

indices = {'resource_types':['tracks','artists'],'time_frames':['short_term','medium_term', 'long_term']}

user_artists_all = []

for time_frame in indices['time_frames']:
  artist_string = 'artists_' + time_frame

  user_artists_all += user_data[artist_string]

print(user_artists_all)

user_artists_ids = []

top_all_time_artists = []
for artist in user_artists_all:
  user_artists_ids.append(artist['id'])

user_artists_ids = list(set(user_artists_ids))

for artist_id in user_artists_ids:
  for artist in user_artists_all:
    if artist_id == artist['id']:
      top_all_time_artists.append(artist)
      break
len(top_all_time_artists)

# top_all_time_artists = user_data['artists_short_term']
# top_all_time_artists

#block to assign artist
# top_all_time_artists = spotify_user.generic_get('https://api.spotify.com/v1/me/top/artists?time_range=long_term&limit=50')

# top_all_time_artists = top_all_time_artists['items']

top_all_time_artists

artists_stripped = []

for artist in top_all_time_artists:
  artists_stripped.append({'name': artist['name'], 'id':artist['id']})


artists_stripped

for artist in artists_stripped:
  related_artist_ids = []
  similar_artists = spotify.generic_get('https://api.spotify.com/v1/artists/' + artist['id'] +'/related-artists')
  for similar_artist in similar_artists['artists']:
    related_artist_ids.append({'name':similar_artist['name'],'id':similar_artist['id']})
  artist['similar_artists'] = related_artist_ids

artists_stripped

artist_map = []

for artist in artists_stripped:
  item = {'name': artist['name'],  'id': artist['id']}
  edges = []
  for similar_artist in artist['similar_artists']:
    for artist_2 in artists_stripped:
      # print(artist)
      # print(similar_artist)
      # print('----------------------------------------------')
      # print(f'{artist_id} ?= {sim_artist_id}')
      # print(artist['name'] + ' ?= ' + artist_2['name'] + '.' + similar_artist['name'])
      if artist_2['id'] == similar_artist['id']:
        edges.append({'name': artist_2['name'], 'id':artist_2['id']})
  item['edges'] = edges
  artist_map.append(item)

artist_map

import networkx as nx

G=nx.Graph()
G

for artist in artist_map:
  G.add_node(artist['name'])

print(G.nodes())

print(len(G.nodes()))

for artist in artist_map:
  for edge in artist['edges']:
    graph_edge = (artist['name'], edge['name'])
    G.add_edge(*graph_edge)

print(G.edges())
len(G.edges())

# G = nx.Graph()

# G.add_node('a')
# G.add_node('b')
# edge= ('a', 'b')
# G.add_edge(*edge)

nx.draw(G,pos = nx.nx_pydot.graphviz_layout(G), with_labels = True,node_color='lightblue', edge_color='gray')

plt.rcParams["figure.figsize"] = (60,30)
# plt.savefig("avery_medium_term.png") # save as png
plt.show() # display

"""Lets make this thing go one layer deeper :O (Work in progress, was attempting to get related artists for each artist in the graph, and make the graph even larger"""

# import time
# artists_level_2 = []

# count = 0
# try:
#   for artist in artists_stripped:
#     for similar_artist in artist['similar_artists']:
#       count = count + 1
#       print(count)
#       related_artist_ids_2 = []
#       similar_artists_2 = spotify.generic_get('https://api.spotify.com/v1/artists/' + similar_artist['id'] +'/related-artists')
      
    
#       for similar_artist_2 in similar_artists_2['artists']:
#         related_artist_ids_2.append({'name':similar_artist_2['name'],'id':similar_artist_2['id']})
#       similar_artist['similar_artists'] = related_artist_ids_2
  

# except Exception as e:
#   print(str(e))

# artists_level_2

# artist_map_2 = []

# count = 0
# for artist in artists_stripped:
#   for sim_artist in artist['similar_artists']:
#     for artist_2 in artists_stripped:
#       if artist['id'] == artist_2['id']:
#         break
#       if artist_2['id'] == sim_artist['id']:
#         break
#       for sim_artist_2 in artist_2['similar_artists']:
#         if artist['id'] == sim_artist_2['id']:
#           break
#         if sim_artist['id'] == sim_artist_2['id'] and artist['id'] != artist_2['id'] and not sim_artist['name'] in artists_stripped:
#           print(artist['name'] + ' -> ' + sim_artist['name'] + ' <- ' + artist_2['name'])
#           count += 1
#           print(count)
#           # print(count)

# # artist_map_2

rec_artists = {}

artists_stripped[0]

url = 'https://accounts.spotify.com/authorize?client_id=5de0c3326eed4e17a4e2b226fc57a68f&response_type=code&response_uri=code&redirect_uri=http://localhost:8888/callback&code_challenge_method=S256&code_challenge=b_XeYv3R3_M'
r = requests.post(url)
print(r.status_code)

for key, val in r.headers.items():
  print(f'{key} : {val}')

r.reason