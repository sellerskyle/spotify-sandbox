# -*- coding: utf-8 -*-
"""QueueOrganizer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13TNUr4ghFBGyIuzivpNazN1k-FyOw6oQ

Spotify doesn't provide an API call to get a user's queue, so we do some creative stuff to get the user's queue, sort it, then add it back. There may be some latency.

Queue can be sorted by any of Spotify's exposed metric, found [here](https://developer.spotify.com/documentation/web-api/reference/#objects-index) in the audio features object

Note: Using this a lot will mess up your spotify metrics, as it technically plays all the songs in your queue everytime you run it
"""

import base64
import datetime
from urllib.parse import urlencode

import requests
import json

#Follows Spotify's "Implicit Grant" Authorization flow
class SpotifyAPI(object):
    access_token = None
    access_token_expires = datetime.datetime.now()
    access_token_did_expire = True
    client_id = None
    client_secret = None
    token_url = "https://accounts.spotify.com/api/token"
    authorization_url = "https://accounts.spotify.com/authorize"
    
    #external functions ("public")
    

    def __init__(self, client_id, client_secret, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client_id = client_id
        self.client_secret = client_secret

    def get_album(self, _id):
        return self.get_resource(_id, resource_type='albums')
    
    def get_artist(self, _id):
        return self.get_resource(_id, resource_type='artists')

    def get_playlist(self, _id):
        return self.get_resource(_id, resource_type='playlists')

    def get_playlist_tracks(self, _id):
        return self.get_resource(_id, resource_type='playlists', addendum='tracks')

    def get_track_features(self, _id):
        return self.get_resource(_id, resource_type='audio-features')

    def get_track_analysis(self, _id):
      return self.get_resource(_id, resource_type='audio-analysis') 

    def search(self, query=None, operator=None, operator_query=None, search_type='artist', limit=20 ):
        if query == None:
            raise Exception("A query is required")
        if isinstance(query, dict):
            query = " ".join([f"{k}:{v}" for k,v in query.items()])
        if operator != None and operator_query != None:
            if operator.lower() == "or" or operator.lower() == "not":
                operator = operator.upper()
                if isinstance(operator_query, str):
                    query = f"{query} {operator} {operator_query}"
        query_params = urlencode({"q": query, "type": search_type.lower(), "limit": str(limit)})
        return self.base_search(query_params)


    #internal functions ("private")


    def get_client_credentials(self):
        """
        Returns a base64 encoded string
        """
        client_id = self.client_id
        client_secret = self.client_secret
        if client_secret == None or client_id == None:
            raise Exception("You must set client_id and client_secret")
        client_creds = f"{client_id}:{client_secret}"
        client_creds_b64 = base64.b64encode(client_creds.encode())
        return client_creds_b64.decode()
    
    def get_token_headers(self):
        client_creds_b64 = self.get_client_credentials()
        return {
            "Authorization": f"Basic {client_creds_b64}"
        }
    
    def get_token_data(self):
        return {
            "grant_type": "client_credentials"
        } 
    
    def perform_auth(self):
        token_url = self.token_url
        token_data = self.get_token_data()
        token_headers = self.get_token_headers()
        r = requests.post(token_url, data=token_data, headers=token_headers)
        if r.status_code not in range(200, 299):
            raise Exception("Could not authenticate client.")
            # return False
        data = r.json()
        now = datetime.datetime.now()
        access_token = data['access_token']
        expires_in = data['expires_in'] # seconds
        expires = now + datetime.timedelta(seconds=expires_in)
        self.access_token = access_token
        self.access_token_expires = expires
        self.access_token_did_expire = expires < now
        return True
    
    def get_access_token(self):
        token = self.access_token
        expires = self.access_token_expires
        now = datetime.datetime.now()
        if expires < now:
            self.perform_auth()
            return self.get_access_token()
        elif token == None:
            self.perform_auth()
            return self.get_access_token() 
        return token
    
    def get_resource_header(self):
        access_token = self.get_access_token()
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        return headers
        
        
    def get_resource(self, lookup_id, resource_type='albums', version='v1', addendum=''):
        endpoint = f"https://api.spotify.com/{version}/{resource_type}/{lookup_id}/{addendum}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()
    
    
    
    def base_search(self, query_params): # type
        headers = self.get_resource_header()
        endpoint = "https://api.spotify.com/v1/search"
        lookup_url = f"{endpoint}?{query_params}"
        r = requests.get(lookup_url, headers=headers)
        if r.status_code not in range(200, 299):  
            return {}
        return r.json()

    #generic api request, accepts the full endpoint string

    def generic_get(self, endpoint):
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            return {}
        return r.json()

    def generic_post(self, endpoint):
        headers = self.get_resource_header()
        r = requests.post(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
          print(r.status_code)
          return r.status_code
        return r.status_code
      

    def generic_put(self, endpoint, data={}):
        headers = self.get_resource_header()
        #r = requests.put(endpoint, headers=headers)
        r = requests.put(endpoint, data=json.dumps(data), headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            return {}
        # return r.json()

    #new functions for user functions

    def get_current_user(self):
        endpoint = f"https://api.spotify.com/v1/me"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_current_user_recently_played(self):
        endpoint = f"https://api.spotify.com/v1/me/player/recently-played"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_current_user_top(self, top_type='tracks', time_range='medium_term'):
        #endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?limit=50&time_range{time_range}"
        endpoint = f"https://api.spotify.com/v1/me/top/{top_type}?time_range={time_range}&limit=50"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            print(r.status_code)
            return {}
        return r.json()

    def get_user(self, user):
        endpoint = f"https://api.spotify.com/v1/users/{user}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

import webbrowser
import json

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
import time

client_id = ""
client_secret = ""

spotify =  SpotifyAPI(client_id, client_secret)

scopes = ['user-read-email', 'user-read-private', 'playlist-read-collaborative', 'playlist-modify-public', 'playlist-read-private', 'playlist-modify-private', 'user-library-read', 'user-top-read', 'user-read-recently-played', 'user-read-currently-playing']
scopes_string = ' '.join(scopes)
authorization_url = "https://accounts.spotify.com/authorize"


params = {
            "client_id": client_id,
            "response_type": "token",
            "redirect_uri": "http://localhost:7777/callback",
            "scope": scopes_string
        }

r = requests.get(authorization_url, params)
print("Successful if this is 200: " + str(r.status_code))
print("URL to paste in browser: " + str(r.url))

#paste the entire url you are sent to here as a string(in quotes)
response = ''
response_list_raw = response.split('&')

response_list = []
#hard coded extracting token and expires
for item in response_list_raw:
  response_list.append(item.split('='))

response_list

access_token = response_list[0][1]
expires_in = response_list[2][1]
print(access_token)

spotify_user = SpotifyAPI(client_id, client_secret)

spotify_user.access_token = access_token
spotify_user.access_token_expires = datetime.datetime.now() + datetime.timedelta(seconds=3600)
spotify_user.access_token_did_expire = False

nu = spotify.search("Khalid", search_type='artist')

u = spotify_user.search("Khalid", search_type='artist')

print(spotify.access_token)
print(nu)
print(spotify_user.access_token)
print(u)

"""End Initialization and test. Begin New stuff"""

#finding jeopardy theme song ID
res = spotify.search('Jeopardy Theme', search_type='track')
res
# for track in res['items']:
#   print(track['name'] + ' : ' + track['id'])

def appendToUserQueue(track_uri):
  spotify_user.generic_post('https://api.spotify.com/v1/me/player/queue' + '?uri=' + track_uri)

def getUserCurrentTrack():
  return spotify_user.generic_get('https://api.spotify.com/v1/me/player/currently-playing')['item']

def getUserCurrentTrackProgress():
  return spotify_user.generic_get('https://api.spotify.com/v1/me/player/currently-playing')['progress_ms']

def skipToNextTrack():
  spotify_user.generic_post('https://api.spotify.com/v1/me/player/next')

def playTrack(track_uri, pos = 0):
  track_json = {}
  track_json['uris'] = [track_uri]
  track_json['position_ms'] = pos
  spotify_user.generic_put('https://api.spotify.com/v1/me/player/play', data = track_json)

def addAudioFeatures(track_list):
  track_id_string = ''
  for track in track_list:
    track_id_string = track_id_string + track['id'] + ','
  track_id_string = track_id_string[:-1] #remove last character of string, as an extra comma was added
  features = spotify.generic_get('https://api.spotify.com/v1/audio-features?ids=' + track_id_string)['audio_features']
  for i in range(len(track_list)):
    track_list[i]['danceability'] = features[i]['danceability']
    track_list[i]['energy'] = features[i]['energy']
    track_list[i]['key'] = features[i]['key']
    track_list[i]['loudness'] = features[i]['loudness']
    track_list[i]['mode'] = features[i]['mode']
    track_list[i]['speechiness'] = features[i]['speechiness']
    track_list[i]['acousticness'] = features[i]['acousticness']
    track_list[i]['instrumentalness'] = features[i]['instrumentalness']
    track_list[i]['liveness'] = features[i]['liveness']
    track_list[i]['valence'] = features[i]['valence']
    track_list[i]['tempo'] = features[i]['tempo']
    track_list[i]['time_signature'] = features[i]['time_signature']

  return track_list

def sortTracksByFeatures(track_list, feature = 'energy', ascending=True):
  def getFeature(track):
    return track[feature]

  # sort list with key
  track_list.sort(key=getFeature, reverse= not ascending)

def sweepVolumeDown(speed = 10):
  for volume in range(0, 101, speed):
    spotify_user.generic_put('https://api.spotify.com/v1/me/player/volume?volume_percent=' + str(100 - volume))

def sweepVolumeUp(speed = 10):
  for volume in range(0, 101, speed):
    spotify_user.generic_put('https://api.spotify.com/v1/me/player/volume?volume_percent=' + str(volume))

#To get the user's queue, we;
#1 - add a song with a known ID (in this case, the jeopardy wait song) to the end of the queue (we could possibly make this the users currently playing song, but what if they have this song in the queue?)
#2 - skip songs until we get to our known ID, adding the ID of each song in the queue to a list
#3 - return the list of tracks 

#Current implementation seems to work, but does is not efficient, need to find a way to wait until posts are complete to do gets
def getUserQueue():
  user_queue = []
  appendToUserQueue('spotify:track:7GyGUC8QFMS9NoHJsgNqh1') #1
  time.sleep(1)
  skipToNextTrack()
  time.sleep(1)
  current_track = getUserCurrentTrack()
  time.sleep(1)
  while current_track['id'] != '7GyGUC8QFMS9NoHJsgNqh1': #2
    user_queue.append(current_track)
    skipToNextTrack()
    time.sleep(1)
    current_track = getUserCurrentTrack()
    time.sleep(1)


  return user_queue #3

#To sort a user's queue, we:
#1 - get the users currently playing track and the time in the track at which we are beginning this
#2 - get the items currently in the User's Queue
#3 - return the user's playback to what they were listening to while we sort their queue
#4 - sort their queue by passed values
#5 - add tracks back to queue in sorted order
def sortUserQueue(feature = 'energy', ascending = True):
  #sweepVolumeDown()
  current_track = getUserCurrentTrack() #1
  progress = getUserCurrentTrackProgress()
  user_queue = getUserQueue() #2
  playTrack(current_track['uri'], pos = progress) #3
  #sweepVolumeUp()
  user_queue_plus_features = addAudioFeatures(user_queue) #4
  sortTracksByFeatures(user_queue_plus_features, feature, ascending)
  for track in user_queue_plus_features: #5
    appendToUserQueue(track['uri'])

sortUserQueue()

queue = getUserQueue()
for track in queue:
  print(track['name'])

for track in queue:
  print(track['name'])