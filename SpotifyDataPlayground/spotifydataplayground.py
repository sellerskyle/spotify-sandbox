# -*- coding: utf-8 -*-
"""SpotifyDataPlayground.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n9JlxRJy1Gw_9YMaUbc6AqNl0ZgIvFae

This notebook serves as a playground for experimenting with data science using Python and Spotify APIs

First we install a few necessary libraries
"""

!pip install -q numpy
!pip install -q pandas
!pip install requests

"""Next, we are using a spotify API client made using a tutorial found here: [video](https://www.youtube.com/watch?v=xdq6Gz33khQ) [GitHub](https://github.com/codingforentrepreneurs/30-Days-of-Python/blob/master/tutorial-reference/Day%2019/notebooks/spotify_client.py)"""

import base64
import datetime
from urllib.parse import urlencode

import requests

#Uses Spotiy's "Client Credentials Flow"
class SpotifyAPI(object):
    access_token = None
    access_token_expires = datetime.datetime.now()
    access_token_did_expire = True
    client_id = None
    client_secret = None
    token_url = "https://accounts.spotify.com/api/token"
    
    #external functions ("public")
    

    def __init__(self, client_id, client_secret, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client_id = client_id
        self.client_secret = client_secret

    def get_album(self, _id):
        return self.get_resource(_id, resource_type='albums')
    
    def get_artist(self, _id):
        return self.get_resource(_id, resource_type='artists')

    def get_playlist(self, _id):
        return self.get_resource(_id, resource_type='playlists')

    def get_playlist_tracks(self, _id):
        return self.get_resource(_id, resource_type='playlists', addendum='tracks')

    def get_track_features(self, _id):
        return self.get_resource(_id, resource_type='audio-features')

    def get_track_analysis(self, _id):
      return self.get_resource(_id, resource_type='audio-analysis') 

    def search(self, query=None, operator=None, operator_query=None, search_type='artist', limit=20 ):
        if query == None:
            raise Exception("A query is required")
        if isinstance(query, dict):
            query = " ".join([f"{k}:{v}" for k,v in query.items()])
        if operator != None and operator_query != None:
            if operator.lower() == "or" or operator.lower() == "not":
                operator = operator.upper()
                if isinstance(operator_query, str):
                    query = f"{query} {operator} {operator_query}"
        query_params = urlencode({"q": query, "type": search_type.lower(), "limit": str(limit)})
        return self.base_search(query_params)


    #internal functions ("private")


    def get_client_credentials(self):
        """
        Returns a base64 encoded string
        """
        client_id = self.client_id
        client_secret = self.client_secret
        if client_secret == None or client_id == None:
            raise Exception("You must set client_id and client_secret")
        client_creds = f"{client_id}:{client_secret}"
        client_creds_b64 = base64.b64encode(client_creds.encode())
        return client_creds_b64.decode()
    
    def get_token_headers(self):
        client_creds_b64 = self.get_client_credentials()
        return {
            "Authorization": f"Basic {client_creds_b64}"
        }
    
    def get_token_data(self):
        return {
            "grant_type": "client_credentials"
        } 
    
    def perform_auth(self):
        token_url = self.token_url
        token_data = self.get_token_data()
        token_headers = self.get_token_headers()
        r = requests.post(token_url, data=token_data, headers=token_headers)
        if r.status_code not in range(200, 299):
            raise Exception("Could not authenticate client.")
            # return False
        data = r.json()
        now = datetime.datetime.now()
        access_token = data['access_token']
        expires_in = data['expires_in'] # seconds
        expires = now + datetime.timedelta(seconds=expires_in)
        self.access_token = access_token
        self.access_token_expires = expires
        self.access_token_did_expire = expires < now
        return True
    
    def get_access_token(self):
        token = self.access_token
        expires = self.access_token_expires
        now = datetime.datetime.now()
        if expires < now:
            self.perform_auth()
            return self.get_access_token()
        elif token == None:
            self.perform_auth()
            return self.get_access_token() 
        return token
    
    def get_resource_header(self):
        access_token = self.get_access_token()
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        return headers
        
        
    def get_resource(self, lookup_id, resource_type='albums', version='v1', addendum=''):
        endpoint = f"https://api.spotify.com/{version}/{resource_type}/{lookup_id}/{addendum}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()
    
    
    
    def base_search(self, query_params): # type
        headers = self.get_resource_header()
        endpoint = "https://api.spotify.com/v1/search"
        lookup_url = f"{endpoint}?{query_params}"
        r = requests.get(lookup_url, headers=headers)
        if r.status_code not in range(200, 299):  
            return {}
        return r.json()

"""Let's not forget to import the all powerful datascience libraries: NumPy and pandas !"""

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt

"""Now, we pass our client ID and client secret from our Spotify Dev project into an instance of the spotify_client class. Paste in your own within the quotes. To get a your Spotify credentials, visit [here](https://developer.spotify.com/dashboard/login)"""

client_id = ""
client_secret = ""

spotify = SpotifyAPI(client_id, client_secret)

spotify.perform_auth()

"""To access the spotify API, we now call spotify.func()
Let's try a simple search for an artist (feel free to change the artist variable to anyone you'd like)
"""

artist = "Calvin Harris"
artist_result_raw = spotify.search(query=artist) 
# the raw json we get back is formatted funny, so we have to dig to get what we want
artists_list = artist_result_raw['artists']['items'] # returns a list of the (max 20) artists that matched the term
top_artist = artists_list[0] # skims the top artist from the list

#cleaning up the artist data to only include that which is relevant
top_artist['followers'] = top_artist['followers']['total']
top_artist.pop('external_urls')
top_artist.pop('href');
top_artist.pop('images');
top_artist.pop('type');
top_artist.pop('uri');
#provides some basic artist profile information
for key, val in top_artist.items():
  print(f"{key}:{val}")

"""Let's try using pandas dataframes to display a list of data. Let's see if we can find some similarities between tracks with generic words in their name. Change the word variable to some generic word (fx: "love", "magic", "beautiful')"""

word = "sun"
tracks_results_raw = spotify.search(query=word, search_type='track', limit=50)
all_tracks = tracks_results_raw['tracks']['items']

for track in all_tracks:
  track['album'] = track['album']['name']
  artists = []
  for artist in track['artists']:
    artists.append(artist['name'])
  track['artists'] = artists
  track.pop('available_markets')
  track.pop('disc_number')
  track.pop('external_ids')
  track.pop('external_urls')
  track.pop('href')
  track.pop('is_local')
  track.pop('preview_url')
  track.pop('track_number')
  track.pop('type')
  track.pop('uri')


tracks_dataframe = pd.DataFrame(all_tracks)
tracks_dataframe

"""How cool! We now see spotify's top 50 tracks for a search term. But wouldn't it be cooler if we could get even more data on tracks than what is seen here? Well, we can do that! Spotify has another api call that gives more detailed information on their tracks."""

all_tracks_features = []

for track in all_tracks:
  all_tracks_features.append(spotify.get_track_features(track['id']))

for feature in all_tracks_features:
  feature.pop('analysis_url')
  feature.pop('duration_ms')
  feature.pop('id')
  feature.pop('track_href')
  feature.pop('type')
  feature.pop('uri')
features_dataframe = pd.DataFrame(all_tracks_features)
features_dataframe.head()

"""And now, we combine the dataframes into a single, data packed dataframe!"""

tracks_dataframe_complete = pd.concat([tracks_dataframe, features_dataframe], axis=1, sort=False)
tracks_dataframe_numeric = tracks_dataframe_complete.drop(columns=['album', 'explicit', 'artists','id','name', 'time_signature'])
tracks_dataframe_complete.head()

"""Now that we have some data built, let's visualize it!"""

tracks_dataframe_numeric.describe()

"""Lets plot the distribution of each attribute for our given word."""

sns.distplot(tracks_dataframe_complete['danceability'], bins =10, hist=False, label="danceability")
sns.distplot(tracks_dataframe_complete['energy'], bins =10, hist=False, label="energy")
sns.distplot(tracks_dataframe_complete['speechiness'], bins =10, hist=False, label="speechiness")
sns.distplot(tracks_dataframe_complete['acousticness'], bins =10, hist=False, label="acousticness")
sns.distplot(tracks_dataframe_complete['liveness'], bins =10, hist=False, label="liveness")
sns.distplot(tracks_dataframe_complete['valence'], bins =10, hist=False, label="valence")
plt.legend()
plt.xlim(left=0.0, right=1.0)
#sns.distplot(tracks_dataframe_complete['instrumentalness'], bins =10, hist=False, label="instrumentalness")

"""Now, let's see how correlated each of these attributes are for this data set."""

correlation_matrix = tracks_dataframe_numeric.corr()
sns.heatmap(correlation_matrix.abs())

"""Let's do this all again, but for for the Global Top 50 (if you'd rather do the US top 50, just uncomment the US top 50 line)"""

playlist_id = '37i9dQZEVXbMDoHDwVN2tF' #global top 50
#playlist_id ='37i9dQZEVXbLRQDuF5jeBp' #US top 50
top_50_raw = spotify.get_playlist_tracks(playlist_id)
type(top_50_raw)
top_50_rare = top_50_raw['items']

top_50_tracks = []
for track in top_50_rare:
  top_50_tracks.append(track['track'])

top_50_tracks[0]

for track in top_50_tracks:
  track['album'] = track['album']['name']
  artists = []
  for artist in track['artists']:
    artists.append(artist['name'])
  track['artists'] = artists
  track.pop('available_markets')
  track.pop('disc_number')
  track.pop('external_ids')
  track.pop('external_urls')
  track.pop('href')
  track.pop('is_local')
  track.pop('preview_url')
  track.pop('track_number')
  track.pop('type')
  track.pop('uri')


top_50_dataframe = pd.DataFrame(top_50_tracks)
top_50_dataframe.head()

top_50_features = []

for track in top_50_tracks:
  top_50_features.append(spotify.get_track_features(track['id']))

for feature in top_50_features:
  feature.pop('analysis_url')
  feature.pop('duration_ms')
  feature.pop('id')
  feature.pop('track_href')
  feature.pop('type')
  feature.pop('uri')
top_50_features_dataframe = pd.DataFrame(top_50_features)
top_50_features_dataframe.head()

top_50_dataframe_complete = pd.concat([top_50_dataframe, top_50_features_dataframe], axis=1, sort=False)
top_50_dataframe_numeric = top_50_dataframe_complete.drop(columns=['album', 'explicit', 'artists','id','name', 'time_signature', 'episode', 'track'])
top_50_dataframe_complete

top_50_dataframe_numeric.head()

top_50_dataframe_numeric.describe()

sns.distplot(top_50_dataframe_complete['popularity']/100, bins =10, hist=False, label="popularity")
sns.distplot(top_50_dataframe_complete['danceability'], bins =10, hist=False, label="danceability")
sns.distplot(top_50_dataframe_complete['energy'], bins =10, hist=False, label="energy")
sns.distplot(top_50_dataframe_complete['speechiness'], bins =10, hist=False, label="speechiness")
sns.distplot(top_50_dataframe_complete['acousticness'], bins =10, hist=False, label="acousticness")
sns.distplot(top_50_dataframe_complete['liveness'], bins =10, hist=False, label="liveness")
sns.distplot(top_50_dataframe_complete['valence'], bins =10, hist=False, label="valence")
plt.legend()
plt.xlim(left=0.0, right=1.0)
#sns.distplot(tracks_dataframe_complete['instrumentalness'], bins =10, hist=False, label="instrumentalness")

top_50_correlation_matrix = top_50_dataframe_numeric.corr()
top_50_correlation_matrix

sns.heatmap(top_50_correlation_matrix.abs())